#include <stdio.h>

int i, j;
int dp0[101][101], dp1[101][101], answer;
int t, T, N, K;

// dp0[인접한 비트의 개수][비트의 자리 수]
// dp1[x+1][인접비트수], 0으로 끝나는건 dp0[x+1][인접비트수] 

int main() {
	for (i = 1; i <= 100; i++) {
    //인접한 비트의 최대값은 N-1이다. (전부 다 1이라고 가정했을때) j 끝값 줘서 반복횟수 줄임
		for (j = 0; j <= i - 1; j++) {
			if (i == 1 && j == 0) {
				dp0[i][j] = dp1[i][j] = 1; // 초기값 셋팅.. 1자리일 때는 무조건 인접한 비트 개수가 0이니깐
			}
			else {
				// 끝자리가 0인 것은 무조건 인접한 비트의 개수가 증가하지 않음
				dp0[i][j] = dp0[i - 1][j] + dp1[i - 1][j];
				// 전 자리가 끝자리수 1이었는데 또 1이면 인접한비트개수 1증가. 0인 경우 그대로
				dp1[i][j] = dp1[i - 1][j - 1] + dp0[i - 1][j];
			}
		}
}
	scanf("%d", &T);

	for (t = 1; t <= T; t++) {
		scanf("%d %d", &N, &K); // 수열의 길이, 구하고자 하는 인접한 비트의 개수
		answer = dp0[N][K] + dp1[N][K];
		printf("%d\n", answer);
	}
}
